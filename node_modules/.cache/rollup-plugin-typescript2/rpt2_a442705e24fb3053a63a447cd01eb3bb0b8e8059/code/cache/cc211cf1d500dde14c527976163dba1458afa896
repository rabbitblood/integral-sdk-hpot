{"code":"import { CurrencyAmount, Percent } from '.';\r\nimport { MaxUint256 } from '../constants/internalConstants';\r\nimport JSBI from 'jsbi';\r\nimport invariant from 'tiny-invariant';\r\nimport { ZERO } from '../constants/internalConstants';\r\nimport { maxLiquidityForAmounts } from '../utils/maxLiquidityForAmounts';\r\nimport { tickToPrice } from '../utils/priceTickConversions';\r\nimport { SqrtPriceMath } from '../utils/sqrtPriceMath';\r\nimport { TickMath } from '../utils/tickMath';\r\nimport { encodeSqrtRatioX96 } from '../utils/encodeSqrtRatioX96';\r\nimport { Pool } from './pool';\r\n/**\r\n * Represents a position on a Algebra Pool\r\n */\r\nexport class Position {\r\n    /**\r\n     * Constructs a position for a given pool with the given liquidity\r\n     * @param pool For which pool the liquidity is assigned\r\n     * @param liquidity The amount of liquidity that is in the position\r\n     * @param tickLower The lower tick of the position\r\n     * @param tickUpper The upper tick of the position\r\n     */\r\n    constructor({ pool, liquidity, tickLower, tickUpper, }) {\r\n        // cached resuts for the getters\r\n        this._token0Amount = null;\r\n        this._token1Amount = null;\r\n        this._mintAmounts = null;\r\n        invariant(tickLower < tickUpper, 'TICK_ORDER');\r\n        invariant(tickLower >= TickMath.MIN_TICK && tickLower % pool.tickSpacing === 0, 'TICK_LOWER');\r\n        invariant(tickUpper <= TickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0, 'TICK_UPPER');\r\n        this.pool = pool;\r\n        this.tickLower = tickLower;\r\n        this.tickUpper = tickUpper;\r\n        this.liquidity = JSBI.BigInt(liquidity);\r\n    }\r\n    /**\r\n     * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at\r\n     * the current price for the pool\r\n     */\r\n    get mintAmounts() {\r\n        if (this._mintAmounts === null) {\r\n            if (this.pool.tickCurrent < this.tickLower) {\r\n                return {\r\n                    amount0: SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),\r\n                    amount1: ZERO,\r\n                };\r\n            }\r\n            else if (this.pool.tickCurrent < this.tickUpper) {\r\n                return {\r\n                    amount0: SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),\r\n                    amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, true),\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    amount0: ZERO,\r\n                    amount1: SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, true),\r\n                };\r\n            }\r\n        }\r\n        return this._mintAmounts;\r\n    }\r\n    /**\r\n     * Returns the price of token0 at the lower tick\r\n     */\r\n    get token0PriceLower() {\r\n        return tickToPrice(this.pool.token0, this.pool.token1, this.tickLower);\r\n    }\r\n    /**\r\n     * Returns the price of token0 at the upper tick\r\n     */\r\n    get token0PriceUpper() {\r\n        return tickToPrice(this.pool.token0, this.pool.token1, this.tickUpper);\r\n    }\r\n    /**\r\n     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price\r\n     */\r\n    get amount0() {\r\n        if (this._token0Amount === null) {\r\n            if (this.pool.tickCurrent < this.tickLower) {\r\n                this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));\r\n            }\r\n            else if (this.pool.tickCurrent < this.tickUpper) {\r\n                this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, SqrtPriceMath.getAmount0Delta(this.pool.sqrtRatioX96, TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));\r\n            }\r\n            else {\r\n                this._token0Amount = CurrencyAmount.fromRawAmount(this.pool.token0, ZERO);\r\n            }\r\n        }\r\n        return this._token0Amount;\r\n    }\r\n    /**\r\n     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price\r\n     */\r\n    get amount1() {\r\n        if (this._token1Amount === null) {\r\n            if (this.pool.tickCurrent < this.tickLower) {\r\n                this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, ZERO);\r\n            }\r\n            else if (this.pool.tickCurrent < this.tickUpper) {\r\n                this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), this.pool.sqrtRatioX96, this.liquidity, false));\r\n            }\r\n            else {\r\n                this._token1Amount = CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));\r\n            }\r\n        }\r\n        return this._token1Amount;\r\n    }\r\n    /**\r\n     * Computes the maximum amount of liquidity received for a given amount of token0, token1,\r\n     * and the prices at the tick boundaries.\r\n     * @param pool The pool for which the position should be created\r\n     * @param tickLower The lower tick of the position\r\n     * @param tickUpper The upper tick of the position\r\n     * @param amount0 token0 amount\r\n     * @param amount1 token1 amount\r\n     * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,\r\n     * not what core can theoretically support\r\n     * @returns The amount of liquidity for the position\r\n     */\r\n    static fromAmounts({ pool, tickLower, tickUpper, amount0, amount1, useFullPrecision, }) {\r\n        const sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\r\n        const sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\r\n        return new Position({\r\n            pool,\r\n            tickLower,\r\n            tickUpper,\r\n            liquidity: maxLiquidityForAmounts(pool.sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision),\r\n        });\r\n    }\r\n    /**\r\n     * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1\r\n     * @param pool The pool for which the position is created\r\n     * @param tickLower The lower tick\r\n     * @param tickUpper The upper tick\r\n     * @param amount0 The desired amount of token0\r\n     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,\r\n     * not what core can theoretically support\r\n     * @returns The position\r\n     */\r\n    static fromAmount0({ pool, tickLower, tickUpper, amount0, useFullPrecision, }) {\r\n        return Position.fromAmounts({\r\n            pool,\r\n            tickLower,\r\n            tickUpper,\r\n            amount0,\r\n            amount1: MaxUint256,\r\n            useFullPrecision,\r\n        });\r\n    }\r\n    /**\r\n     * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0\r\n     * @param pool The pool for which the position is created\r\n     * @param tickLower The lower tick\r\n     * @param tickUpper The upper tick\r\n     * @param amount1 The desired amount of token1\r\n     * @returns The position\r\n     */\r\n    static fromAmount1({ pool, tickLower, tickUpper, amount1, }) {\r\n        // this function always uses full precision,\r\n        return Position.fromAmounts({\r\n            pool,\r\n            tickLower,\r\n            tickUpper,\r\n            amount0: MaxUint256,\r\n            amount1,\r\n            useFullPrecision: true,\r\n        });\r\n    }\r\n    /**\r\n     * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position\r\n     * with the given slippage tolerance\r\n     * @param slippageTolerance Tolerance of unfavorable slippage from the current price\r\n     * @returns The amounts, with slippage\r\n     */\r\n    mintAmountsWithSlippage(slippageTolerance) {\r\n        // get lower/upper prices\r\n        const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance);\r\n        // construct counterfactual pools\r\n        const poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, this.pool.deployer, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower), this.pool.tickSpacing);\r\n        const poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, this.pool.deployer, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper), this.pool.tickSpacing);\r\n        // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)\r\n        const positionThatWillBeCreated = Position.fromAmounts({\r\n            pool: this.pool,\r\n            tickLower: this.tickLower,\r\n            tickUpper: this.tickUpper,\r\n            ...this.mintAmounts,\r\n            useFullPrecision: false,\r\n        });\r\n        // we want the smaller amounts...\r\n        // ...which occurs at the upper price for amount0...\r\n        const { amount0 } = new Position({\r\n            pool: poolUpper,\r\n            liquidity: positionThatWillBeCreated.liquidity,\r\n            tickLower: this.tickLower,\r\n            tickUpper: this.tickUpper,\r\n        }).mintAmounts;\r\n        // ...and the lower for amount1\r\n        const { amount1 } = new Position({\r\n            pool: poolLower,\r\n            liquidity: positionThatWillBeCreated.liquidity,\r\n            tickLower: this.tickLower,\r\n            tickUpper: this.tickUpper,\r\n        }).mintAmounts;\r\n        return { amount0, amount1 };\r\n    }\r\n    /**\r\n     * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the\r\n     * position with the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the current price\r\n     * @returns The amounts, with slippage\r\n     */\r\n    burnAmountsWithSlippage(slippageTolerance) {\r\n        // get lower/upper prices\r\n        const { sqrtRatioX96Upper, sqrtRatioX96Lower } = this.ratiosAfterSlippage(slippageTolerance);\r\n        // construct counterfactual pools\r\n        const poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, this.pool.deployer, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower), this.pool.tickSpacing);\r\n        const poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, this.pool.deployer, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper), this.pool.tickSpacing);\r\n        // we want the smaller amounts...\r\n        // ...which occurs at the upper price for amount0...\r\n        const amount0 = new Position({\r\n            pool: poolUpper,\r\n            liquidity: this.liquidity,\r\n            tickLower: this.tickLower,\r\n            tickUpper: this.tickUpper,\r\n        }).amount0;\r\n        // ...and the lower for amount1\r\n        const amount1 = new Position({\r\n            pool: poolLower,\r\n            liquidity: this.liquidity,\r\n            tickLower: this.tickLower,\r\n            tickUpper: this.tickUpper,\r\n        }).amount1;\r\n        return { amount0: amount0.quotient, amount1: amount1.quotient };\r\n    }\r\n    /**\r\n     * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage\r\n     * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert\r\n     * @returns The sqrt ratios after slippage\r\n     */\r\n    ratiosAfterSlippage(slippageTolerance) {\r\n        const priceLower = this.pool.token0Price.asFraction.multiply(new Percent(1).subtract(slippageTolerance));\r\n        const priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));\r\n        let sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);\r\n        if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {\r\n            sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));\r\n        }\r\n        let sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);\r\n        if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {\r\n            sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));\r\n        }\r\n        return {\r\n            sqrtRatioX96Lower,\r\n            sqrtRatioX96Upper,\r\n        };\r\n    }\r\n}\r\n//# sourceMappingURL=position.js.map","references":["D:/personal_programming_work/integral-sdk-hpot/src/entities/index.ts","D:/personal_programming_work/integral-sdk-hpot/src/types/BigIntish.ts","D:/personal_programming_work/integral-sdk-hpot/src/constants/internalConstants.ts","D:/personal_programming_work/integral-sdk-hpot/node_modules/jsbi/jsbi.d.ts","D:/personal_programming_work/integral-sdk-hpot/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","D:/personal_programming_work/integral-sdk-hpot/src/constants/internalConstants.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/maxLiquidityForAmounts.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/priceTickConversions.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/sqrtPriceMath.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/tickMath.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/encodeSqrtRatioX96.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/pool.ts"],"map":"{\"version\":3,\"file\":\"position.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/position.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/personal_programming_work/integral-sdk-hpot/entities/position.d.ts","writeByteOrderMark":false,"text":"import { CurrencyAmount, Percent, Price, Token } from '.';\r\nimport { BigintIsh } from '../types/BigIntish';\r\nimport JSBI from 'jsbi';\r\nimport { Pool } from './pool';\r\ninterface PositionConstructorArgs {\r\n    pool: Pool;\r\n    tickLower: number;\r\n    tickUpper: number;\r\n    liquidity: BigintIsh;\r\n}\r\n/**\r\n * Represents a position on a Algebra Pool\r\n */\r\nexport declare class Position {\r\n    readonly pool: Pool;\r\n    readonly tickLower: number;\r\n    readonly tickUpper: number;\r\n    readonly liquidity: JSBI;\r\n    private _token0Amount;\r\n    private _token1Amount;\r\n    /**\r\n     * Constructs a position for a given pool with the given liquidity\r\n     * @param pool For which pool the liquidity is assigned\r\n     * @param liquidity The amount of liquidity that is in the position\r\n     * @param tickLower The lower tick of the position\r\n     * @param tickUpper The upper tick of the position\r\n     */\r\n    constructor({ pool, liquidity, tickLower, tickUpper, }: PositionConstructorArgs);\r\n    private _mintAmounts;\r\n    /**\r\n     * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at\r\n     * the current price for the pool\r\n     */\r\n    get mintAmounts(): Readonly<{\r\n        amount0: JSBI;\r\n        amount1: JSBI;\r\n    }>;\r\n    /**\r\n     * Returns the price of token0 at the lower tick\r\n     */\r\n    get token0PriceLower(): Price<Token, Token>;\r\n    /**\r\n     * Returns the price of token0 at the upper tick\r\n     */\r\n    get token0PriceUpper(): Price<Token, Token>;\r\n    /**\r\n     * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price\r\n     */\r\n    get amount0(): CurrencyAmount<Token>;\r\n    /**\r\n     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price\r\n     */\r\n    get amount1(): CurrencyAmount<Token>;\r\n    /**\r\n     * Computes the maximum amount of liquidity received for a given amount of token0, token1,\r\n     * and the prices at the tick boundaries.\r\n     * @param pool The pool for which the position should be created\r\n     * @param tickLower The lower tick of the position\r\n     * @param tickUpper The upper tick of the position\r\n     * @param amount0 token0 amount\r\n     * @param amount1 token1 amount\r\n     * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,\r\n     * not what core can theoretically support\r\n     * @returns The amount of liquidity for the position\r\n     */\r\n    static fromAmounts({ pool, tickLower, tickUpper, amount0, amount1, useFullPrecision, }: {\r\n        pool: Pool;\r\n        tickLower: number;\r\n        tickUpper: number;\r\n        amount0: BigintIsh;\r\n        amount1: BigintIsh;\r\n        useFullPrecision: boolean;\r\n    }): Position;\r\n    /**\r\n     * Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1\r\n     * @param pool The pool for which the position is created\r\n     * @param tickLower The lower tick\r\n     * @param tickUpper The upper tick\r\n     * @param amount0 The desired amount of token0\r\n     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,\r\n     * not what core can theoretically support\r\n     * @returns The position\r\n     */\r\n    static fromAmount0({ pool, tickLower, tickUpper, amount0, useFullPrecision, }: {\r\n        pool: Pool;\r\n        tickLower: number;\r\n        tickUpper: number;\r\n        amount0: BigintIsh;\r\n        useFullPrecision: boolean;\r\n    }): Position;\r\n    /**\r\n     * Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0\r\n     * @param pool The pool for which the position is created\r\n     * @param tickLower The lower tick\r\n     * @param tickUpper The upper tick\r\n     * @param amount1 The desired amount of token1\r\n     * @returns The position\r\n     */\r\n    static fromAmount1({ pool, tickLower, tickUpper, amount1, }: {\r\n        pool: Pool;\r\n        tickLower: number;\r\n        tickUpper: number;\r\n        amount1: BigintIsh;\r\n    }): Position;\r\n    /**\r\n     * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position\r\n     * with the given slippage tolerance\r\n     * @param slippageTolerance Tolerance of unfavorable slippage from the current price\r\n     * @returns The amounts, with slippage\r\n     */\r\n    mintAmountsWithSlippage(slippageTolerance: Percent): Readonly<{\r\n        amount0: JSBI;\r\n        amount1: JSBI;\r\n    }>;\r\n    /**\r\n     * Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the\r\n     * position with the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the current price\r\n     * @returns The amounts, with slippage\r\n     */\r\n    burnAmountsWithSlippage(slippageTolerance: Percent): Readonly<{\r\n        amount0: JSBI;\r\n        amount1: JSBI;\r\n    }>;\r\n    /**\r\n     * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage\r\n     * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert\r\n     * @returns The sqrt ratios after slippage\r\n     */\r\n    private ratiosAfterSlippage;\r\n}\r\nexport {};\r\n"}}
