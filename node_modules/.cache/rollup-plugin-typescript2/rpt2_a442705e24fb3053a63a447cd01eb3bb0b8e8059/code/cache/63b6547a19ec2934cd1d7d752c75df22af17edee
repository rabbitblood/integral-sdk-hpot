{"code":"import { AbstractCurrency } from './AbstractCurrency';\r\nimport invariant from 'tiny-invariant';\r\nimport { validateAndParseAddress } from '../utils/validateAndParseAddress';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport class Token extends AbstractCurrency {\r\n    constructor(chainId, address, decimals, symbol, name) {\r\n        super(chainId, decimals, symbol, name);\r\n        this.isNative = false;\r\n        this.isToken = true;\r\n        this.chainId = chainId;\r\n        this.address = validateAndParseAddress(address);\r\n    }\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other) {\r\n        return (other.isToken &&\r\n            this.chainId === other.chainId &&\r\n            this.address === other.address);\r\n    }\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other) {\r\n        invariant(this.chainId === other.chainId, 'CHAIN_IDS');\r\n        invariant(this.address !== other.address, 'ADDRESSES');\r\n        return this.address.toLowerCase() < other.address.toLowerCase();\r\n    }\r\n    /**\r\n     * Return this token, which does not need to be wrapped\r\n     */\r\n    get wrapped() {\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport function currencyEquals(currencyA, currencyB) {\r\n    if (currencyA instanceof Token && currencyB instanceof Token) {\r\n        return currencyA.equals(currencyB);\r\n    }\r\n    else if (currencyA instanceof Token) {\r\n        return false;\r\n    }\r\n    else if (currencyB instanceof Token) {\r\n        return false;\r\n    }\r\n    else {\r\n        return currencyA === currencyB;\r\n    }\r\n}\r\n//# sourceMappingURL=Token.js.map","references":["D:/personal_programming_work/integral-sdk-hpot/src/entities/AbstractCurrency.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/Currency.ts","D:/personal_programming_work/integral-sdk-hpot/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/validateAndParseAddress.ts"],"map":"{\"version\":3,\"file\":\"Token.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/Token.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD,OAAO,SAAS,MAAM,gBAAgB,CAAC;AACvC,OAAO,EAAE,uBAAuB,EAAE,MAAM,kCAAkC,CAAC;AAC3E;;GAEG;AACH,MAAM,OAAO,KAAM,SAAQ,gBAAgB;IAOzC,YACE,OAAe,EACf,OAAe,EACf,QAAgB,EAChB,MAAe,EACf,IAAa;QAEb,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QAVzB,aAAQ,GAAU,KAAK,CAAC;QACxB,YAAO,GAAS,IAAI,CAAC;QAUnC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;IAClD,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,KAAe;QAC3B,OAAO,CACL,KAAK,CAAC,OAAO;YACb,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO;YAC9B,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,CAC/B,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACI,WAAW,CAAC,KAAY;QAC7B,SAAS,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QACvD,SAAS,CAAC,IAAI,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QACvD,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;IAClE,CAAC;IAED;;OAEG;IACH,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC;IACd,CAAC;CACF;AAED;;GAEG;AACH,MAAM,UAAU,cAAc,CAC5B,SAAmB,EACnB,SAAmB;IAEnB,IAAI,SAAS,YAAY,KAAK,IAAI,SAAS,YAAY,KAAK,EAAE;QAC5D,OAAO,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;KACpC;SAAM,IAAI,SAAS,YAAY,KAAK,EAAE;QACrC,OAAO,KAAK,CAAC;KACd;SAAM,IAAI,SAAS,YAAY,KAAK,EAAE;QACrC,OAAO,KAAK,CAAC;KACd;SAAM;QACL,OAAO,SAAS,KAAK,SAAS,CAAC;KAChC;AACH,CAAC\"}","dts":{"name":"D:/personal_programming_work/integral-sdk-hpot/entities/Token.d.ts","writeByteOrderMark":false,"text":"import { AbstractCurrency } from './AbstractCurrency';\r\nimport { Currency } from './Currency';\r\n/**\r\n * Represents an ERC20 token with a unique address and some metadata.\r\n */\r\nexport declare class Token extends AbstractCurrency {\r\n    readonly chainId: number;\r\n    readonly address: string;\r\n    readonly isNative: false;\r\n    readonly isToken: true;\r\n    constructor(chainId: number, address: string, decimals: number, symbol?: string, name?: string);\r\n    /**\r\n     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\r\n     * @param other other token to compare\r\n     */\r\n    equals(other: Currency): boolean;\r\n    /**\r\n     * Returns true if the address of this token sorts before the address of the other token\r\n     * @param other other token to compare\r\n     * @throws if the tokens have the same address\r\n     * @throws if the tokens are on different chains\r\n     */\r\n    sortsBefore(other: Token): boolean;\r\n    /**\r\n     * Return this token, which does not need to be wrapped\r\n     */\r\n    get wrapped(): Token;\r\n}\r\n/**\r\n * Compares two currencies for equality\r\n */\r\nexport declare function currencyEquals(currencyA: Currency, currencyB: Currency): boolean;\r\n"}}
