{"code":"import { Interface } from '@ethersproject/abi';\r\nimport { validateAndParseAddress } from '../utils/validateAndParseAddress';\r\nimport { CurrencyAmount } from '../entities';\r\nimport { TradeType } from '../enums/tradeType';\r\nimport invariant from 'tiny-invariant';\r\nimport { ADDRESS_ZERO } from '../constants/constants';\r\nimport { SelfPermit } from './selfPermit';\r\nimport { encodeRouteToPath } from '../utils';\r\nimport { toHex } from '../utils/calldata';\r\nimport { algebraSwapRouterABI } from \"../abis/algebraSwapRouter\";\r\n/**\r\n * Represents the SwapRouter, and has static methods for helping execute trades.\r\n */\r\nexport class SwapRouter extends SelfPermit {\r\n    /**\r\n     * Cannot be constructed.\r\n     */\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n     * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n     * @param trade to produce call parameters for\r\n     * @param options options for the call parameters\r\n     */\r\n    static swapCallParameters(trades, options) {\r\n        if (!Array.isArray(trades)) {\r\n            trades = [trades];\r\n        }\r\n        const sampleTrade = trades[0];\r\n        const tokenIn = sampleTrade.inputAmount.currency.wrapped;\r\n        const tokenOut = sampleTrade.outputAmount.currency.wrapped;\r\n        // All trades should have the same starting and ending token.\r\n        invariant(trades.every(trade => trade.inputAmount.currency.wrapped.equals(tokenIn)), 'TOKEN_IN_DIFF');\r\n        invariant(trades.every(trade => trade.outputAmount.currency.wrapped.equals(tokenOut)), 'TOKEN_OUT_DIFF');\r\n        const calldatas = [];\r\n        const ZERO_IN = CurrencyAmount.fromRawAmount(trades[0].inputAmount.currency, 0);\r\n        const ZERO_OUT = CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0);\r\n        const totalAmountOut = trades.reduce((sum, trade) => sum.add(trade.minimumAmountOut(options.slippageTolerance)), ZERO_OUT);\r\n        // flag for whether a refund needs to happen\r\n        const mustRefund = sampleTrade.inputAmount.currency.isNative &&\r\n            sampleTrade.tradeType === TradeType.EXACT_OUTPUT;\r\n        const inputIsNative = sampleTrade.inputAmount.currency.isNative;\r\n        // flags for whether funds should be send first to the router\r\n        const outputIsNative = sampleTrade.outputAmount.currency.isNative;\r\n        const routerMustCustody = outputIsNative || !!options.fee;\r\n        const totalValue = inputIsNative\r\n            ? trades.reduce((sum, trade) => sum.add(trade.maximumAmountIn(options.slippageTolerance)), ZERO_IN)\r\n            : ZERO_IN;\r\n        // encode permit if necessary\r\n        if (options.inputTokenPermit) {\r\n            invariant(sampleTrade.inputAmount.currency.isToken, 'NON_TOKEN_PERMIT');\r\n            calldatas.push(SwapRouter.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));\r\n        }\r\n        const recipient = validateAndParseAddress(options.recipient);\r\n        const deadline = toHex(options.deadline);\r\n        for (const trade of trades) {\r\n            for (const { route, inputAmount, outputAmount } of trade.swaps) {\r\n                const amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount)\r\n                    .quotient);\r\n                const amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount)\r\n                    .quotient);\r\n                // flag for whether the trade is single hop or not\r\n                const singleHop = route.pools.length === 1;\r\n                if (singleHop) {\r\n                    if (trade.tradeType === TradeType.EXACT_INPUT) {\r\n                        const exactInputSingleParams = {\r\n                            tokenIn: route.tokenPath[0].address,\r\n                            tokenOut: route.tokenPath[1].address,\r\n                            deployer: ADDRESS_ZERO,\r\n                            recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\r\n                            deadline,\r\n                            amountIn,\r\n                            amountOutMinimum: amountOut,\r\n                            limitSqrtPrice: toHex(options.sqrtPriceLimitX96 ?? 0),\r\n                        };\r\n                        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData(options.feeOnTransfer && !inputIsNative\r\n                            ? 'exactInputSingleSupportingFeeOnTransferTokens'\r\n                            : 'exactInputSingle', [exactInputSingleParams]));\r\n                    }\r\n                    else {\r\n                        const exactOutputSingleParams = {\r\n                            tokenIn: route.tokenPath[0].address,\r\n                            tokenOut: route.tokenPath[1].address,\r\n                            recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\r\n                            deployer: ADDRESS_ZERO,\r\n                            deadline,\r\n                            amountOut,\r\n                            amountInMaximum: amountIn,\r\n                            limitSqrtPrice: toHex(options.sqrtPriceLimitX96 ?? 0),\r\n                        };\r\n                        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutputSingle', [\r\n                            exactOutputSingleParams,\r\n                        ]));\r\n                    }\r\n                }\r\n                else {\r\n                    invariant(options.sqrtPriceLimitX96 === undefined, 'MULTIHOP_PRICE_LIMIT');\r\n                    const path = encodeRouteToPath(route, trade.tradeType === TradeType.EXACT_OUTPUT);\r\n                    if (trade.tradeType === TradeType.EXACT_INPUT) {\r\n                        const exactInputParams = {\r\n                            path,\r\n                            recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\r\n                            deadline,\r\n                            amountIn,\r\n                            amountOutMinimum: amountOut,\r\n                        };\r\n                        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInput', [\r\n                            exactInputParams,\r\n                        ]));\r\n                    }\r\n                    else {\r\n                        const exactOutputParams = {\r\n                            path,\r\n                            recipient: routerMustCustody ? ADDRESS_ZERO : recipient,\r\n                            deadline,\r\n                            amountOut,\r\n                            amountInMaximum: amountIn,\r\n                        };\r\n                        calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactOutput', [\r\n                            exactOutputParams,\r\n                        ]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // unwrap\r\n        if (routerMustCustody) {\r\n            if (!!options.fee) {\r\n                const feeRecipient = validateAndParseAddress(options.fee.recipient);\r\n                const fee = toHex(options.fee.fee.multiply(10000).quotient);\r\n                if (outputIsNative) {\r\n                    calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('unwrapWNativeTokenWithFee', [toHex(totalAmountOut.quotient), recipient, fee, feeRecipient]));\r\n                }\r\n                else {\r\n                    calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('sweepTokenWithFee', [\r\n                        sampleTrade.outputAmount.currency.wrapped.address,\r\n                        toHex(totalAmountOut.quotient),\r\n                        recipient,\r\n                        fee,\r\n                        feeRecipient,\r\n                    ]));\r\n                }\r\n            }\r\n            else {\r\n                calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('unwrapWNativeToken', [\r\n                    toHex(totalAmountOut.quotient),\r\n                    recipient,\r\n                ]));\r\n            }\r\n        }\r\n        // refund\r\n        if (mustRefund) {\r\n            calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('refundNativeToken'));\r\n        }\r\n        return {\r\n            calldata: calldatas,\r\n            value: toHex(totalValue.quotient),\r\n        };\r\n    }\r\n}\r\nSwapRouter.INTERFACE = new Interface(algebraSwapRouterABI);\r\n//# sourceMappingURL=swapRouter.js.map","references":["D:/personal_programming_work/integral-sdk-hpot/node_modules/@ethersproject/abi/lib/index.d.ts","D:/personal_programming_work/integral-sdk-hpot/src/types/BigIntish.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/validateAndParseAddress.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/index.ts","D:/personal_programming_work/integral-sdk-hpot/src/enums/tradeType.ts","D:/personal_programming_work/integral-sdk-hpot/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/trade.ts","D:/personal_programming_work/integral-sdk-hpot/src/constants/constants.ts","D:/personal_programming_work/integral-sdk-hpot/src/classes/selfPermit.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/index.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/calldata.ts","D:/personal_programming_work/integral-sdk-hpot/src/abis/algebraSwapRouter.ts"],"map":"{\"version\":3,\"file\":\"swapRouter.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/classes/swapRouter.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/personal_programming_work/integral-sdk-hpot/classes/swapRouter.d.ts","writeByteOrderMark":false,"text":"import { Interface } from '@ethersproject/abi';\r\nimport { BigintIsh } from '../types/BigIntish';\r\nimport { Currency, Percent } from '../entities';\r\nimport { TradeType } from '../enums/tradeType';\r\nimport { Trade } from '../entities/trade';\r\nimport { PermitOptions, SelfPermit } from './selfPermit';\r\nimport { MethodParameters } from '../utils/calldata';\r\nexport interface FeeOptions {\r\n    /**\r\n     * The percent of the output that will be taken as a fee.\r\n     */\r\n    fee: Percent;\r\n    /**\r\n     * The recipient of the fee.\r\n     */\r\n    recipient: string;\r\n}\r\n/**\r\n * Options for producing the arguments to send calls to the router.\r\n */\r\nexport interface SwapOptions {\r\n    /**\r\n     * How much the execution price is allowed to move unfavorably from the trade execution price.\r\n     */\r\n    slippageTolerance: Percent;\r\n    /**\r\n     * The account that should receive the output.\r\n     */\r\n    recipient: string;\r\n    /**\r\n     * When the transaction expires, in epoch seconds.\r\n     */\r\n    deadline: BigintIsh;\r\n    /**\r\n     * Deflationary token.\r\n     */\r\n    feeOnTransfer: boolean;\r\n    /**\r\n     * The optional permit parameters for spending the input.\r\n     */\r\n    inputTokenPermit?: PermitOptions;\r\n    /**\r\n     * The optional price limit for the trade.\r\n     */\r\n    sqrtPriceLimitX96?: BigintIsh;\r\n    /**\r\n     * Optional information for taking a fee on output.\r\n     */\r\n    fee?: FeeOptions;\r\n}\r\n/**\r\n * Represents the SwapRouter, and has static methods for helping execute trades.\r\n */\r\nexport declare abstract class SwapRouter extends SelfPermit {\r\n    static INTERFACE: Interface;\r\n    /**\r\n     * Cannot be constructed.\r\n     */\r\n    private constructor();\r\n    /**\r\n     * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\r\n     * @param trade to produce call parameters for\r\n     * @param options options for the call parameters\r\n     */\r\n    static swapCallParameters(trades: Trade<Currency, Currency, TradeType> | Trade<Currency, Currency, TradeType>[], options: SwapOptions): MethodParameters;\r\n}\r\n"}}
