{"code":"import { CurrencyAmount, Fraction, Percent, Price, } from '../entities';\r\nimport { sortedInsert } from '../utils/sortedInsert';\r\nimport { TradeType } from '../enums/tradeType';\r\nimport invariant from 'tiny-invariant';\r\nimport { ONE, ZERO } from '../constants';\r\nimport { Pool } from './pool';\r\nimport { Route } from './route';\r\n/**\r\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n * @param a The first trade to compare\r\n * @param b The second trade to compare\r\n * @returns A sorted ordering for two neighboring elements in a trade array\r\n */\r\nexport function tradeComparator(a, b) {\r\n    // must have same input and output token for comparison\r\n    invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY');\r\n    invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY');\r\n    if (a.outputAmount.equalTo(b.outputAmount)) {\r\n        if (a.inputAmount.equalTo(b.inputAmount)) {\r\n            // consider the number of hops since each hop costs gas\r\n            const aHops = a.swaps.reduce((total, cur) => total + cur.route.tokenPath.length, 0);\r\n            const bHops = b.swaps.reduce((total, cur) => total + cur.route.tokenPath.length, 0);\r\n            return aHops - bHops;\r\n        }\r\n        // trade A requires less input than trade B, so A should come first\r\n        if (a.inputAmount.lessThan(b.inputAmount)) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        // tradeA has less output than trade B, so should come second\r\n        if (a.outputAmount.lessThan(b.outputAmount)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a trade executed against a set of routes where some percentage of the input is\r\n * split across each route.\r\n *\r\n * Each route has its own set of pools. Pools can not be re-used across routes.\r\n *\r\n * Does not account for slippage, i.e., changes in price environment that can occur between\r\n * the time the trade is submitted and when it is executed.\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n */\r\nexport class Trade {\r\n    /**\r\n     * Construct a trade by passing in the pre-computed property values\r\n     * @param routes The routes through which the trade occurs\r\n     * @param tradeType The type of trade, exact input or exact output\r\n     */\r\n    constructor({ routes, tradeType, }) {\r\n        const inputCurrency = routes[0].inputAmount.currency;\r\n        const outputCurrency = routes[0].outputAmount.currency;\r\n        invariant(routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)), 'INPUT_CURRENCY_MATCH');\r\n        invariant(routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)), 'OUTPUT_CURRENCY_MATCH');\r\n        const numPools = routes\r\n            .map(({ route }) => route.pools.length)\r\n            .reduce((total, cur) => total + cur, 0);\r\n        const poolAddressSet = new Set();\r\n        for (const { route } of routes) {\r\n            for (const pool of route.pools) {\r\n                poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1));\r\n            }\r\n        }\r\n        invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED');\r\n        this.swaps = routes;\r\n        this.tradeType = tradeType;\r\n    }\r\n    /**\r\n     * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\r\n     * this will return an error.\r\n     *\r\n     * When the trade consists of just a single route, this returns the route of the trade,\r\n     * i.e. which pools the trade goes through.\r\n     */\r\n    get route() {\r\n        invariant(this.swaps.length == 1, 'MULTIPLE_ROUTES');\r\n        return this.swaps[0].route;\r\n    }\r\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\r\n    get inputAmount() {\r\n        if (this._inputAmount) {\r\n            return this._inputAmount;\r\n        }\r\n        const inputCurrency = this.swaps[0].inputAmount.currency;\r\n        const totalInputFromRoutes = this.swaps\r\n            .map(({ inputAmount }) => inputAmount)\r\n            .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0));\r\n        this._inputAmount = totalInputFromRoutes;\r\n        return this._inputAmount;\r\n    }\r\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\r\n    get outputAmount() {\r\n        if (this._outputAmount) {\r\n            return this._outputAmount;\r\n        }\r\n        const outputCurrency = this.swaps[0].outputAmount.currency;\r\n        const totalOutputFromRoutes = this.swaps\r\n            .map(({ outputAmount }) => outputAmount)\r\n            .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0));\r\n        this._outputAmount = totalOutputFromRoutes;\r\n        return this._outputAmount;\r\n    }\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    get executionPrice() {\r\n        return (this._executionPrice ??\r\n            (this._executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient)));\r\n    }\r\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\r\n    get priceImpact() {\r\n        if (this._priceImpact) {\r\n            return this._priceImpact;\r\n        }\r\n        let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);\r\n        for (const { route, inputAmount } of this.swaps) {\r\n            const midPrice = route.midPrice;\r\n            spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));\r\n        }\r\n        const priceImpact = spotOutputAmount\r\n            .subtract(this.outputAmount)\r\n            .divide(spotOutputAmount);\r\n        this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator);\r\n        return this._priceImpact;\r\n    }\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact in trade\r\n     * @param amountIn The amount being passed in\r\n     * @returns The exact in trade\r\n     */\r\n    static async exactIn(route, amountIn) {\r\n        return Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT);\r\n    }\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact out trade\r\n     * @param amountOut The amount returned by the trade\r\n     * @returns The exact out trade\r\n     */\r\n    static async exactOut(route, amountOut) {\r\n        return Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT);\r\n    }\r\n    /**\r\n     * Constructs a trade by simulating swaps through the given route\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param route route to swap through\r\n     * @param amount the amount specified, either input or output, depending on tradeType\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The route\r\n     */\r\n    static async fromRoute(route, amount, tradeType) {\r\n        const amounts = new Array(route.tokenPath.length);\r\n        let inputAmount;\r\n        let outputAmount;\r\n        if (tradeType === TradeType.EXACT_INPUT) {\r\n            invariant(amount.currency.equals(route.input), 'INPUT');\r\n            amounts[0] = amount.wrapped;\r\n            for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n                const pool = route.pools[i];\r\n                const [outputAmount] = await pool.getOutputAmount(amounts[i]);\r\n                amounts[i + 1] = outputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\r\n        }\r\n        else {\r\n            invariant(amount.currency.equals(route.output), 'OUTPUT');\r\n            amounts[amounts.length - 1] = amount.wrapped;\r\n            for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n                const pool = route.pools[i - 1];\r\n                const [inputAmount] = await pool.getInputAmount(amounts[i]);\r\n                amounts[i - 1] = inputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n        }\r\n        return new Trade({\r\n            routes: [{ inputAmount, outputAmount, route }],\r\n            tradeType,\r\n        });\r\n    }\r\n    /**\r\n     * Constructs a trade from routes by simulating swaps\r\n     *\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param routes the routes to swap through and how much of the amount should be routed through each\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The trade\r\n     */\r\n    static async fromRoutes(routes, tradeType) {\r\n        const populatedRoutes = [];\r\n        for (const { route, amount } of routes) {\r\n            const amounts = new Array(route.tokenPath.length);\r\n            let inputAmount;\r\n            let outputAmount;\r\n            if (tradeType === TradeType.EXACT_INPUT) {\r\n                invariant(amount.currency.equals(route.input), 'INPUT');\r\n                inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n                amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);\r\n                for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n                    const pool = route.pools[i];\r\n                    const [outputAmount] = await pool.getOutputAmount(amounts[i]);\r\n                    amounts[i + 1] = outputAmount;\r\n                }\r\n                outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\r\n            }\r\n            else {\r\n                invariant(amount.currency.equals(route.output), 'OUTPUT');\r\n                outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n                amounts[amounts.length - 1] = CurrencyAmount.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);\r\n                for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n                    const pool = route.pools[i - 1];\r\n                    const [inputAmount] = await pool.getInputAmount(amounts[i]);\r\n                    amounts[i - 1] = inputAmount;\r\n                }\r\n                inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);\r\n            }\r\n            populatedRoutes.push({ route, inputAmount, outputAmount });\r\n        }\r\n        return new Trade({\r\n            routes: populatedRoutes,\r\n            tradeType,\r\n        });\r\n    }\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTrade(constructorArguments) {\r\n        return new Trade({\r\n            ...constructorArguments,\r\n            routes: [\r\n                {\r\n                    inputAmount: constructorArguments.inputAmount,\r\n                    outputAmount: constructorArguments.outputAmount,\r\n                    route: constructorArguments.route,\r\n                },\r\n            ],\r\n        });\r\n    }\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTradeWithMultipleRoutes(constructorArguments) {\r\n        return new Trade(constructorArguments);\r\n    }\r\n    /**\r\n     * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact in trade\r\n     */\r\n    static async bestTradeExactIn(pools, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountIn = currencyAmountIn, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const amountIn = nextAmountIn.wrapped;\r\n        const tokenOut = currencyOut.wrapped;\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!pool.token0.equals(amountIn.currency) &&\r\n                !pool.token1.equals(amountIn.currency))\r\n                continue;\r\n            let amountOut;\r\n            try {\r\n                [amountOut] = await pool.getOutputAmount(amountIn);\r\n            }\r\n            catch (_error) {\r\n                const error = _error;\r\n                // input too low\r\n                if (error.isInsufficientInputAmountError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the output token, so this is the final trade of one of the paths\r\n            if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([...currentPools, pool], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools\r\n                    .slice(0, i)\r\n                    .concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1,\r\n                }, [...currentPools, pool], amountOut, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the desired currency amount out\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact out trade\r\n     */\r\n    static async bestTradeExactOut(pools, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountOut = currencyAmountOut, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountOut === nextAmountOut || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const amountOut = nextAmountOut.wrapped;\r\n        const tokenIn = currencyIn.wrapped;\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!pool.token0.equals(amountOut.currency) &&\r\n                !pool.token1.equals(amountOut.currency))\r\n                continue;\r\n            let amountIn;\r\n            try {\r\n                [amountIn] = await pool.getInputAmount(amountOut);\r\n            }\r\n            catch (_error) {\r\n                // not enough liquidity in this pool\r\n                const error = _error;\r\n                if (error.isInsufficientReservesError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the input token, so this is the first trade of one of the paths\r\n            if (amountIn.currency.equals(tokenIn)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([pool, ...currentPools], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools\r\n                    .slice(0, i)\r\n                    .concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1,\r\n                }, [pool, ...currentPools], amountIn, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount out\r\n     */\r\n    minimumAmountOut(slippageTolerance, amountOut = this.outputAmount) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n            return amountOut;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountOut = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .invert()\r\n                .multiply(amountOut.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);\r\n        }\r\n    }\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount in\r\n     */\r\n    maximumAmountIn(slippageTolerance, amountIn = this.inputAmount) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_INPUT) {\r\n            return amountIn;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountIn = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .multiply(amountIn.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);\r\n        }\r\n    }\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     * @returns The execution price\r\n     */\r\n    worstExecutionPrice(slippageTolerance) {\r\n        return new Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\r\n    }\r\n}\r\n//# sourceMappingURL=trade.js.map","references":["D:/personal_programming_work/integral-sdk-hpot/src/entities/index.ts","D:/personal_programming_work/integral-sdk-hpot/src/utils/sortedInsert.ts","D:/personal_programming_work/integral-sdk-hpot/src/enums/tradeType.ts","D:/personal_programming_work/integral-sdk-hpot/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","D:/personal_programming_work/integral-sdk-hpot/src/constants/index.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/pool.ts","D:/personal_programming_work/integral-sdk-hpot/src/entities/route.ts"],"map":"{\"version\":3,\"file\":\"trade.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/trade.ts\"],\"names\":[],\"mappings\":\"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\"}"}
